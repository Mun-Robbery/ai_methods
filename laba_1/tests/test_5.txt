Многопоточность - это способность программы выполнять несколько задач параллельно. Представьте ресторан: один повар (однопоточность) может готовить только одно блюдо за раз, а несколько поваров (многопоточность) могут готовить разные блюда одновременно.
Основные понятия:

Поток (Thread) - наименьшая единица выполнения программы
Параллелизм - одновременное выполнение задач
Синхронизация - координация работы потоков

Вот простой пример создания потоков в Python:
pythonCopyimport threading
import time

def print_numbers():
    for i in range(5):
        time.sleep(1)  # Имитируем долгую работу
        print(f"Число {i}")

def print_letters():
    for letter in 'ABCDE':
        time.sleep(1)  # Имитируем долгую работу
        print(f"Буква {letter}")

# Создаем потоки
thread1 = threading.Thread(target=print_numbers)
thread2 = threading.Thread(target=print_letters)

# Запускаем потоки
thread1.start()
thread2.start()

# Ждем завершения потоков
thread1.join()
thread2.join()

print("Все потоки завершили работу!")
При запуске этого кода, вы увидите, что числа и буквы выводятся параллельно, а не последовательно.
Вот еще один пример, показывающий использование общих данных между потоками:
pythonCopyimport threading

# Общий счетчик
counter = 0
# Блокировка для синхронизации
lock = threading.Lock()

def increment():
    global counter
    for _ in range(100000):
        with lock:  # Используем блокировку для защиты общих данных
            global counter
            counter += 1

# Создаем два потока
thread1 = threading.Thread(target=increment)
thread2 = threading.Thread(target=increment)

thread1.start()
thread2.start()

thread1.join()
thread2.join()

print(f"Итоговое значение счетчика: {counter}")
Этот пример демонстрирует важный аспект многопоточности - необходимость синхронизации при работе с общими данными. Без использования Lock() результат был бы недетерминированным из-за состояния гонки (race condition).
Основные преимущества многопоточности:

Улучшение производительности для задач с ожиданием (I/O-bound tasks)
Более эффективное использование ресурсов процессора
Возможность выполнения параллельных задач

Ограничения:

В Python есть GIL (Global Interpreter Lock), который ограничивает параллельное выполнение CPU-bound задач
Сложность отладки многопоточных программ
Возможность возникновения состояний гонки и deadlock'ов